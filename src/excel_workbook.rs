use indicatif::MultiProgress;
use rust_xlsxwriter::{Workbook, Worksheet};
use std::{fs::File, io::BufWriter, path::Path};

use crate::{
    AnaliseDosCreditos, BUFFER_CAPACITY, ConsolidacaoCST, DocsFiscais, EFDError, EFDResult,
    ResultExt, SheetType, get_properties, get_worksheets,
};

/// Create excel xlsx file from data_efd, data_cst, data_nat.
///
/// data_efd can be divided into N Worksheets generated by N different threads.
pub fn create_xlsx(
    path_xlsx: &Path,
    data_efd: &[DocsFiscais],
    data_cst: &[ConsolidacaoCST],
    data_nat: &[AnaliseDosCreditos],
) -> EFDResult<()> {
    let file = File::create(path_xlsx).map_loc(|e| EFDError::InOut {
        source: e,
        path: path_xlsx.to_path_buf(),
    })?;

    // BufWriter maior para lidar com o stream de compressão do XLSX
    let buffer = BufWriter::with_capacity(BUFFER_CAPACITY, file);

    let mut workbook = Workbook::new();
    let properties = get_properties()?;
    workbook.set_properties(&properties);

    let multiprogressbar: MultiProgress = MultiProgress::new();

    // Gerar planilhas em paralelo
    let worksheets: Vec<Worksheet> =
        get_all_worksheets(data_efd, data_cst, data_nat, &multiprogressbar)?;

    // Transferir ownership para o workbook
    for worksheet in worksheets {
        // Add the worksheets to the workbook.
        workbook.push_worksheet(worksheet);
    }

    // Otimização final: salvar para o buffer otimizado
    workbook.save_to_writer(buffer)?;
    Ok(())
}

/// Generate worksheets using Rayon scope for heterogeneous tasks
fn get_all_worksheets(
    data_efd: &[DocsFiscais],
    data_cst: &[ConsolidacaoCST],
    data_nat: &[AnaliseDosCreditos],
    multiprogressbar: &MultiProgress,
) -> EFDResult<Vec<Worksheet>> {
    // Inicializamos os resultados como Erro ou Vazio para garantir a segurança de memória
    let mut res_efd = Ok(vec![]);
    let mut res_cst = Ok(vec![]);
    let mut res_nat = Ok(vec![]);

    // Rayon scope: usa o pool de threads existente (i9-9900K - 16 threads)
    // É a alternativa idiomática para N tarefas diferentes sem aninhar 'join'
    rayon::scope(|s| {
        s.spawn(|_| {
            res_efd = get_worksheets(data_efd, SheetType::ItensDocsFiscais, multiprogressbar, 0)
        });
        s.spawn(|_| {
            res_cst = get_worksheets(data_cst, SheetType::ConsolidacaoCST, multiprogressbar, 1)
        });
        s.spawn(|_| {
            res_nat = get_worksheets(data_nat, SheetType::AnaliseCreditos, multiprogressbar, 2)
        });
    });

    // Processamento funcional dos resultados:
    // 1. Coloca os 3 resultados em um array
    // 2. 'collect' transforma Vec<Result<Vec<T>>> em Result<Vec<Vec<T>>> (Early return se houver erro)
    // 3. 'flatten' achata a estrutura para o retorno final
    [res_efd, res_cst, res_nat]
        .into_iter()
        .collect::<EFDResult<Vec<Vec<Worksheet>>>>()
        .map(|v| v.into_iter().flatten().collect())
        .map_loc(|e| {
            eprintln!("Erro em get_all_worksheets: {e}");
            e
        })
}
