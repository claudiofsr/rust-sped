use indicatif::MultiProgress;

use std::{io::Write, path::PathBuf, thread};

// https://github.com/jmcnamara/rust_xlsxwriter/issues/1
// https://rustxlsxwriter.github.io/index.html
use rust_xlsxwriter::{DocProperties, ExcelDateTime, Workbook, Worksheet};

use crate::{
    AnaliseDosCreditos, ConsolidacaoCST, DocsFiscais, EFDResult, OUTPUT_DIRECTORY, OUTPUT_FILENAME,
    get_worksheets,
};

/// Create excel xlsx file from data_efd, data_cst, data_nat.
///
/// data_efd can be divided into N Worksheets generated by N different threads.
pub fn create_xlsx(
    data_efd: &[DocsFiscais],
    data_cst: &[ConsolidacaoCST],
    data_nat: &[AnaliseDosCreditos],
    write: &mut dyn Write,
) -> EFDResult<()> {
    let mut excel_file: PathBuf = [OUTPUT_DIRECTORY, OUTPUT_FILENAME].iter().collect();
    excel_file.set_extension("xlsx");
    writeln!(write, "Write Excel xlsx file: {:?}\n", excel_file.display())?;

    let mut workbook = Workbook::new();
    let properties = get_properties()?;
    workbook.set_properties(&properties);

    let multiprogressbar: MultiProgress = MultiProgress::new();

    let worksheets: Vec<Worksheet> =
        get_all_worksheets(data_efd, data_cst, data_nat, &multiprogressbar)?;

    for worksheet in worksheets {
        // Add the worksheets to the workbook.
        workbook.push_worksheet(worksheet);
    }

    workbook.save(excel_file)?;

    Ok(())
}

fn get_properties() -> EFDResult<DocProperties> {
    // Create a datetime object.
    let date = ExcelDateTime::from_ymd(2023, 1, 1)?.and_hms(0, 0, 0)?;

    // Add it to the document metadata.
    let properties = DocProperties::new()
        .set_title("SPED EFD Contribuições em Excel")
        .set_subject("Informações extraídas de arquivos de SPED EFD Contribuições")
        .set_author("Claudio FSR (https://github.com/claudiofsr/rust-sped)")
        .set_keywords("SPED EFD Contribuições, Rust, Excel")
        .set_comment("Created with Rust and rust_xlsxwriter")
        .set_hyperlink_base("https://github.com/claudiofsr/rust-sped")
        .set_creation_datetime(&date);

    Ok(properties)
}

/// Generate worksheets with thread scope
fn get_all_worksheets(
    data_efd: &[DocsFiscais],
    data_cst: &[ConsolidacaoCST],
    data_nat: &[AnaliseDosCreditos],
    multiprogressbar: &MultiProgress,
) -> EFDResult<Vec<Worksheet>> {
    // Use std::thread in the following functions (these functions are independent of each other):
    let results: EFDResult<Vec<Vec<Worksheet>>> = thread::scope(|s| {
        let thread_efd = s.spawn(|| -> EFDResult<Vec<Worksheet>> {
            let sheet_name = "Itens de Docs Fiscais";
            get_worksheets(data_efd, sheet_name, multiprogressbar, 0)
        });
        let thread_cst = s.spawn(|| -> EFDResult<Vec<Worksheet>> {
            let sheet_name = "Consolidação CST";
            get_worksheets(data_cst, sheet_name, multiprogressbar, 1)
        });
        let thread_nat = s.spawn(|| -> EFDResult<Vec<Worksheet>> {
            let sheet_name = "Análise dos Créditos";
            get_worksheets(data_nat, sheet_name, multiprogressbar, 2)
        });

        // Wait for background thread to complete.
        // Call join() on each handle to make sure all the threads finish.
        // join() returns immediately when the associated thread completes.

        let threads: EFDResult<Vec<_>> = [thread_efd, thread_cst, thread_nat]
            .into_iter()
            .flat_map(|scoped_join_handle| scoped_join_handle.join())
            .collect();

        threads
    });

    let worksheets: Vec<Worksheet> = match results {
        Ok(w) => w.into_iter().flatten().collect(),
        Err(e) => {
            eprintln!("fn get_all_worksheets()");
            eprintln!("Failed to generate worksheets!");
            return Err(e);
        }
    };

    Ok(worksheets)
}
